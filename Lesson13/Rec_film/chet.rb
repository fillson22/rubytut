m = [1, 2, 3, 4, 5, 6, 7]
m.each_with_index {|e,i| puts e if i%2 == 0}
#m.each_with_index {|e,i| puts e if i%2 != 0}
#В вашем решении:

#s = (0..m.size-1).to_a
#Теперь s — это массив, состоящий из чисел, являющихся индексами элементов. 
#Короче говоря [0,1,2,3,4,5,6].
#
#Если у целого числа вызвать метод [0], то мы получим последний символ в двоичной
#записи этого числа
#2.1.4 :018 > 2[0]
# => 0 
#2.1.4 :019 > 3[0]
# => 1
#Именно этим мы пользуемся в блоке метода partition. i[0].zero? вернёт true для чётных
#индексов, и false для нечётных. То есть, как вы совершенно правильно рассказали про partition, 
#делим массив на два — сперва чётные номера, потом нечётные.

#print s.partition{ |i| i[0].zero? }
#=> [[0, 2, 4, 6], [1, 3, 5]] 

#flaten просто вытаскивает все вложенные элементы и выстраивает их в однородный массив. 
#У нас получится массив индексов. Осталось только вытащить из m элементы с этими индексами 
#с помощью .map{ |i| m[i] }